// swift-format-ignore-file

private import Foundation
public import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Information to advertise how to access the current server.
public struct BindingConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var isSecure: Bool {
    get { _isSecure ?? false }
    set { _isSecure = newValue }
  }

  /// Returns true if `isSecure` has been explicitly set.
  package var hasIsSecure: Bool { self._isSecure != nil }
  /// Clears the value of `isSecure`. Subsequent reads from it will return its default value.
  package mutating func clearIsSecure() { self._isSecure = nil }

  package var port: UInt32 {
    get { _port ?? 0 }
    set { _port = newValue }
  }

  /// Returns true if `port` has been explicitly set.
  package var hasPort: Bool { self._port != nil }
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  package mutating func clearPort() { self._port = nil }

  package var hosts: [String] = []

  @_documentation(visibility: internal)
  public var unknownFields = SwiftProtobuf.UnknownStorage()

  @_documentation(visibility: internal)
  public init() {}

  private var _isSecure: Bool?
  private var _port: UInt32?
}

#if swift(>=5.5) && canImport(_Concurrency)
  extension BindingConfiguration: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension BindingConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
  SwiftProtobuf._ProtoNameProviding
{
  public static let protoMessageName: String = "BindingConfiguration"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_secure"), 2: .same(proto: "port"), 9: .same(proto: "hosts"),
  ]

  public mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber { case 1: try decoder.decodeSingularBoolField(value: &self._isSecure)
        case 2: try decoder.decodeSingularUInt32Field(value: &self._port)
        case 9: try decoder.decodeRepeatedStringField(value: &self.hosts)
        default: break
      }
    }
  }

  public func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if let v = self._isSecure { try visitor.visitSingularBoolField(value: v, fieldNumber: 1) }
    try {
      if let v = self._port { try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2) }
    }()
    if !self.hosts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hosts, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func == (lhs: BindingConfiguration, rhs: BindingConfiguration) -> Bool {
    if lhs._isSecure != rhs._isSecure { return false }
    if lhs._port != rhs._port { return false }
    if lhs.hosts != rhs.hosts { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}
