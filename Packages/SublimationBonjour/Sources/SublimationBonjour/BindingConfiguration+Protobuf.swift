//
//  ServerConfiguration.pb.swift
//  SublimationBonjour
//
//  Created by Leo Dion.
//  Copyright © 2024 BrightDigit.
//
//  Permission is hereby granted, free of charge, to any person
//  obtaining a copy of this software and associated documentation
//  files (the “Software”), to deal in the Software without
//  restriction, including without limitation the rights to use,
//  copy, modify, merge, publish, distribute, sublicense, and/or
//  sell copies of the Software, and to permit persons to whom the
//  Software is furnished to do so, subject to the following
//  conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED “AS IS”, WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
//  OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
//  HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
//  WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
//  FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
//  OTHER DEALINGS IN THE SOFTWARE.
//

private import Foundation
package import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

public struct BindingConfiguration {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  package var isSecure: Bool {
    get { _isSecure ?? false }
    set { _isSecure = newValue }
  }

  /// Returns true if `isSecure` has been explicitly set.
  package var hasIsSecure: Bool { self._isSecure != nil }
  /// Clears the value of `isSecure`. Subsequent reads from it will return its default value.
  package mutating func clearIsSecure() { self._isSecure = nil }

  package var port: UInt32 {
    get { _port ?? 0 }
    set { _port = newValue }
  }

  /// Returns true if `port` has been explicitly set.
  package var hasPort: Bool { self._port != nil }
  /// Clears the value of `port`. Subsequent reads from it will return its default value.
  package mutating func clearPort() { self._port = nil }

  package var hosts: [String] = []

  package var unknownFields = SwiftProtobuf.UnknownStorage()

  package init() {}

  private var _isSecure: Bool?
  private var _port: UInt32?
}

#if swift(>=5.5) && canImport(_Concurrency)
  extension BindingConfiguration: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

extension BindingConfiguration: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase,
  SwiftProtobuf._ProtoNameProviding
{
  package static let protoMessageName: String = "ServerConfiguration"
  package static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "is_secure"), 2: .same(proto: "port"), 9: .same(proto: "hosts"),
  ]

  package mutating func decodeMessage(decoder: inout some SwiftProtobuf.Decoder) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber { case 1: try decoder.decodeSingularBoolField(value: &self._isSecure)
        case 2: try decoder.decodeSingularUInt32Field(value: &self._port)
        case 9: try decoder.decodeRepeatedStringField(value: &self.hosts)
        default: break
      }
    }
  }

  package func traverse(visitor: inout some SwiftProtobuf.Visitor) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    if let v = self._isSecure { try visitor.visitSingularBoolField(value: v, fieldNumber: 1) }
    try {
      if let v = self._port { try visitor.visitSingularUInt32Field(value: v, fieldNumber: 2) }
    }()
    if !self.hosts.isEmpty {
      try visitor.visitRepeatedStringField(value: self.hosts, fieldNumber: 9)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func == (lhs: BindingConfiguration, rhs: BindingConfiguration) -> Bool {
    if lhs._isSecure != rhs._isSecure { return false }
    if lhs._port != rhs._port { return false }
    if lhs.hosts != rhs.hosts { return false }
    if lhs.unknownFields != rhs.unknownFields { return false }
    return true
  }
}
